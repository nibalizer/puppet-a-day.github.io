<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Puppet a day</title><link>http://puppet-a-day.com/</link><description>crowdsourced community blog</description><atom:link href="http://puppet-a-day.com/feeds/daenney.rss.xml" rel="self"></atom:link><lastBuildDate>Tue, 20 May 2014 00:00:00 +0000</lastBuildDate><item><title>Puppet caching</title><link>http://puppet-a-day.com/blog/2014/05/20/puppet-caching/</link><description>&lt;p&gt;With Puppet 3.6 out the door and the new caching mechanisms it provides I
started exploring how to do caching with Puppet. A thank you goes out to
&lt;a href="https://github.com/kbarber" title="Github - Ken Barber"&gt;Ken Barber&lt;/a&gt; of &lt;a href="http://www.puppetlabs.com" title="Puppet Labs"&gt;Puppet Labs&lt;/a&gt; and &lt;a href="https://github.com/dalen" title="Github - Erik Dalén"&gt;Erik Dalén&lt;/a&gt; of
&lt;a href="http://www.spotify.com" title="Spotify"&gt;Spotify&lt;/a&gt; for their help on this&amp;nbsp;quest.&lt;/p&gt;
&lt;p&gt;The first thing I wanted to do is use the new caching mechanism for directory
based environments on Puppet 3.6 in such a way that our production environment
would be cached forever. Of course we also need a way to invalidate that cache
when we deploy but between two deploys this code never ever&amp;nbsp;changes.&lt;/p&gt;
&lt;h2 id="directory-based-environments-cache"&gt;Directory-based environments&amp;nbsp;cache&lt;/h2&gt;
&lt;p&gt;First order of business, turn on caching in &lt;code&gt;/etc/puppet/puppet.conf&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="na"&gt;environment_timeout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;unlimited&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Restart the Puppet master and there you go. All the &lt;code&gt;*.pp&lt;/code&gt; files are now parsed
once (instead of being reparsed every 5s or so). Problem is, how do we
invalidate this&amp;nbsp;cache?&lt;/p&gt;
&lt;p&gt;If you&amp;#8217;re running the &amp;#8216;community&amp;#8217; stack all it takes is to tell Passenger to
reload. This can be done by simply touching the &lt;code&gt;tmp/restart.txt&lt;/code&gt; file that
Passenger looks for. On the next request it receives, Passenger will reload and
the Puppet Master will now reparse the &lt;code&gt;*.pp&lt;/code&gt; files for the&amp;nbsp;environment.&lt;/p&gt;
&lt;p&gt;The location of the &lt;code&gt;tmp/&lt;/code&gt; directory varies but it&amp;#8217;s right next to where the
&lt;code&gt;config.ru&lt;/code&gt; file is&amp;nbsp;located:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;.
├── config.ru
├── public
└── tmp
    └── restart.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There is no need to remove the &lt;code&gt;restart.txt&lt;/code&gt; file, Passenger looks at the
timestamp when a request comes in and makes the right&amp;nbsp;decision.&lt;/p&gt;
&lt;p&gt;If you&amp;#8217;re deploying with Capistrano you can override the &lt;code&gt;finalize_update&lt;/code&gt; task
and add something like this in&amp;nbsp;it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;task&lt;/span&gt; &lt;span class="ss"&gt;:finalize_update&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;try_sudo&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt; touch /usr/share/puppet/ext/rack/tmp/restart.txt&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="nginx-cache"&gt;Nginx&amp;nbsp;cache&lt;/h2&gt;
&lt;p&gt;The second thing I wanted to do is cache a few more things at the nginx level.
If you drill down a bit into Puppet you&amp;#8217;ll notice that one of the things the
agent does frequently is request things from the following&amp;nbsp;endpoints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/$environment/file_metadata&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/$environment/file_metadatas&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/$environment/file_content&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These endpoints are computationally expensive; &lt;code&gt;file_metadata&lt;/code&gt; for example ends
up running &lt;code&gt;md5sum&lt;/code&gt; over every file that is being transferred and
&lt;code&gt;file_metadatas&lt;/code&gt; does the same but in bulk for the plugins that are being&amp;nbsp;synced.&lt;/p&gt;
&lt;p&gt;As you can imagine, &lt;code&gt;md5sum&lt;/code&gt; over all these files constantly is slow and also
pretty useless as we just stated that these files don&amp;#8217;t change except for when
we deploy. Prime candidate for some fancy&amp;nbsp;caching!&lt;/p&gt;
&lt;p&gt;The first thing to do is configure the cache space itself in nginx. This &lt;em&gt;must&lt;/em&gt;
be done in the &lt;a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_path" title="NGINX - proxy_cache_path"&gt;&lt;code&gt;http&lt;/code&gt;&lt;/a&gt;&amp;nbsp;block.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;proxy_cache_path&lt;/span&gt; &lt;span class="s"&gt;/var/cache/nginx&lt;/span&gt; &lt;span class="s"&gt;levels=1&lt;/span&gt; &lt;span class="s"&gt;keys_zone=puppetmaster:10m&lt;/span&gt; &lt;span class="s"&gt;max_size=500m&lt;/span&gt; &lt;span class="s"&gt;inactive=60m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;proxy_temp_path&lt;/span&gt; &lt;span class="s"&gt;/var/cache/tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;What we&amp;#8217;ve configured here is a cache space who&amp;#8217;s files will live in
&lt;code&gt;/var/cache/nginx&lt;/code&gt;, have a directory structure of 1 level/folder deep, a
&lt;code&gt;key_zone&lt;/code&gt; size of 10 megabytes, allowed to grow to 500 megabytes of disk space
and entries will be removed after 60 minutes if not being&amp;nbsp;hit.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;proxy_temp_path&lt;/code&gt; is a filesystem location where temporary files that nginx
creates for its own purposes will live. It&amp;#8217;s a good idea for these directories
to be on the &lt;em&gt;same&lt;/em&gt;&amp;nbsp;filesystem.&lt;/p&gt;
&lt;p&gt;Up next, configuring the actual cache for the&amp;nbsp;proxy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="p"&gt;~&lt;/span&gt; &lt;span class="sr"&gt;^/production/file_(metadatas?|content)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_redirect&lt;/span&gt;             &lt;span class="no"&gt;off&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_cache&lt;/span&gt;                &lt;span class="s"&gt;puppetmaster&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_cache_valid&lt;/span&gt;          &lt;span class="mi"&gt;200&lt;/span&gt; &lt;span class="mi"&gt;302&lt;/span&gt; &lt;span class="mi"&gt;15m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_cache_valid&lt;/span&gt;          &lt;span class="mi"&gt;404&lt;/span&gt; &lt;span class="mi"&gt;1m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_pass&lt;/span&gt;                 &lt;span class="s"&gt;http://puppetmaster&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This block tells nginx to match certain paths in the request and proxy those to
the Puppet Master but by using the cache. A backend response of &lt;code&gt;200&lt;/code&gt; or &lt;code&gt;302&lt;/code&gt;
is cached for 15 minutes, a &lt;code&gt;404&lt;/code&gt; is cached for&amp;nbsp;1m.&lt;/p&gt;
&lt;p&gt;Notice that we&amp;#8217;re only matching &lt;code&gt;/production&lt;/code&gt;, the production environment and
not any other. This is done on purpose, the other environments are usually for
testing that map to a feature-branch in git. We usually have no need to cache
these as they are&amp;nbsp;short-lived.&lt;/p&gt;
&lt;p&gt;A somewhat complete configuration looks like&amp;nbsp;this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;upstream&lt;/span&gt; &lt;span class="s"&gt;puppetmaster&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="s"&gt;unix:/path/to/passenger/puppetmaster/socket/file.sock&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt;              &lt;span class="mi"&gt;8140&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;root&lt;/span&gt;                &lt;span class="s"&gt;/usr/share/puppet/ext/rack&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;ssl_certificate&lt;/span&gt;     &lt;span class="s"&gt;/var/lib/puppet/ssl/certs/&lt;/span&gt;&lt;span class="nv"&gt;$FQDN.pem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;ssl_certificate_key&lt;/span&gt; &lt;span class="s"&gt;/var/lib/puppet/ssl/private_keys/&lt;/span&gt;&lt;span class="nv"&gt;$FQDN.pem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;ssl_verify_client&lt;/span&gt;   &lt;span class="s"&gt;optional&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;# All HTTP API requests, requiring a valid certificate&lt;/span&gt;
    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;if&lt;/span&gt; &lt;span class="s"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$ssl_client_verify&lt;/span&gt; &lt;span class="s"&gt;!=&lt;/span&gt; &lt;span class="s"&gt;SUCCESS)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;403&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="kn"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_set_header&lt;/span&gt;  &lt;span class="s"&gt;X-Client-Verify&lt;/span&gt;  &lt;span class="nv"&gt;$ssl_client_verify&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_set_header&lt;/span&gt;  &lt;span class="s"&gt;X-Client-DN&lt;/span&gt;      &lt;span class="nv"&gt;$ssl_client_s_dn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_set_header&lt;/span&gt;  &lt;span class="s"&gt;X-SSL-Subject&lt;/span&gt;    &lt;span class="nv"&gt;$ssl_client_s_dn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_set_header&lt;/span&gt;  &lt;span class="s"&gt;X-SSL-Issuer&lt;/span&gt;     &lt;span class="nv"&gt;$ssl_client_i_dn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_redirect&lt;/span&gt;    &lt;span class="no"&gt;off&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_pass&lt;/span&gt;        &lt;span class="s"&gt;http://puppetmaster&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;


    &lt;span class="c1"&gt;# Requests for cached endpoints, requiring a valid certificate&lt;/span&gt;
    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="p"&gt;~&lt;/span&gt; &lt;span class="sr"&gt;^/production/file_(metadatas?|content)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;if&lt;/span&gt; &lt;span class="s"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$ssl_client_verify&lt;/span&gt; &lt;span class="s"&gt;!=&lt;/span&gt; &lt;span class="s"&gt;SUCCESS)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;403&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="kn"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_cache_valid&lt;/span&gt;  &lt;span class="mi"&gt;200&lt;/span&gt; &lt;span class="mi"&gt;302&lt;/span&gt; &lt;span class="mi"&gt;15m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_cache_valid&lt;/span&gt;  &lt;span class="mi"&gt;404&lt;/span&gt; &lt;span class="mi"&gt;1m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_pass&lt;/span&gt;         &lt;span class="s"&gt;http://puppetmaster&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_set_header&lt;/span&gt;   &lt;span class="s"&gt;X-Client-Verify&lt;/span&gt;  &lt;span class="nv"&gt;$ssl_client_verify&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_set_header&lt;/span&gt;   &lt;span class="s"&gt;X-Client-DN&lt;/span&gt;      &lt;span class="nv"&gt;$ssl_client_s_dn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_set_header&lt;/span&gt;   &lt;span class="s"&gt;X-SSL-Subject&lt;/span&gt;    &lt;span class="nv"&gt;$ssl_client_s_dn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_set_header&lt;/span&gt;   &lt;span class="s"&gt;X-SSL-Issuer&lt;/span&gt;     &lt;span class="nv"&gt;$ssl_client_i_dn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_redirect&lt;/span&gt;     &lt;span class="no"&gt;off&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_cache&lt;/span&gt;        &lt;span class="s"&gt;puppetmaster&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;# Requests for /certificate, used before a valid certificate&lt;/span&gt;
    &lt;span class="c1"&gt;# has been recieved, therefor not requiring $ssl_client_verify&lt;/span&gt;
    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/certificate&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_redirect&lt;/span&gt;    &lt;span class="no"&gt;off&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_pass&lt;/span&gt;        &lt;span class="s"&gt;http://puppetmaster&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Reload your nginx configuration and enjoy. Keep in mind that this cache will
not speed up agent run times but will mostly decrease load on your&amp;nbsp;masters.&lt;/p&gt;
&lt;p&gt;We are left with one problem though; how do we invalidate this cache at deploy
time? Throwing away the cache is pretty easy, just remove all files in
&lt;code&gt;/var/cache/nginx&lt;/code&gt; and you&amp;#8217;re done. Trouble is, you probably don&amp;#8217;t have the
permissions to do so and you probably don&amp;#8217;t want to be &lt;code&gt;sudo&lt;/code&gt;ing during your
deploy to do&amp;nbsp;so.&lt;/p&gt;
&lt;p&gt;Enter mod_lua for nginx. This allows us to create an endpoint on the Puppet
Master vhost that we can hit, simply with cURL, which will take care of
throwing away the cache. Beware that this is a hack, albeit an awesome&amp;nbsp;one:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/cache_purge&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;limit_except&lt;/span&gt; &lt;span class="s"&gt;POST&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;allow&lt;/span&gt; &lt;span class="mi"&gt;127&lt;/span&gt;&lt;span class="s"&gt;.0.0.1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;allow&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;deny&lt;/span&gt; &lt;span class="s"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kn"&gt;content_by_lua&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;
        &lt;span class="s"&gt;os.execute(&amp;quot;find&lt;/span&gt; &lt;span class="s"&gt;/var/cache/nginx&lt;/span&gt; &lt;span class="s"&gt;-type&lt;/span&gt; &lt;span class="s"&gt;f&lt;/span&gt; &lt;span class="s"&gt;-delete&amp;quot;)&lt;/span&gt;
        &lt;span class="s"&gt;ngx.status&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;204&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I&amp;#8217;m sure you can guess what this does. You can now post to &lt;code&gt;/cache_purge&lt;/code&gt; which
in turn, by using the power of Lua, executes the necessary command to clear up
the&amp;nbsp;cache.&lt;/p&gt;
&lt;p&gt;Going back to the Capistrano example earlier you can now add this&amp;nbsp;too:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;task&lt;/span&gt; &lt;span class="ss"&gt;:finalize_update&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;try_sudo&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt; touch /usr/share/puppet/ext/rack/tmp/restart.txt&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;curl --silent -k -X POST https://localhost:8140/cache_purge&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I personally frown on the &lt;code&gt;-k&lt;/code&gt; in the cURL command here so I suggest you
alter it to include &lt;code&gt;--cacert&lt;/code&gt; and point that to
&lt;code&gt;/var/lib/puppet/ssl/certs/ca.pem&lt;/code&gt; instead.&lt;/p&gt;
&lt;h2 id="apache-cache"&gt;Apache&amp;nbsp;cache&lt;/h2&gt;
&lt;p&gt;The cache configuration for nginx is inspired based on what &lt;a href="https://github.com/dalen" title="Github - Erik Dalén"&gt;Erik Dalén&lt;/a&gt;
has been doing at Spotify and decided to&amp;nbsp;share:&lt;/p&gt;
&lt;script src="https://gist.github.com/dalen/6672186.js"&gt;&lt;/script&gt;

&lt;p&gt;Note that this configuration is not caching the &lt;code&gt;file_metadatas&lt;/code&gt; endpoint, I
suggest you do. It also expires the cache after 300 seconds, 5m, and can grow
up to &lt;span class="caps"&gt;1GB&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m familiar enough with Apache to be able to tell you that this stores the
cache in &lt;span class="caps"&gt;RAM&lt;/span&gt; but I have no idea how to invalidate it at deploy&amp;nbsp;time.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Daenney</dc:creator><pubDate>Tue, 20 May 2014 00:00:00 +0000</pubDate><guid>tag:puppet-a-day.com,2014-05-20:blog/2014/05/20/puppet-caching/</guid></item><item><title>Contributing to modules</title><link>http://puppet-a-day.com/blog/2014/04/23/contributing-to-modules/</link><description>&lt;p&gt;As one of the &amp;#8216;maintainers&amp;#8217; of &lt;a href="https://github.com/puppetlabs/puppetlabs-apt"&gt;puppetlabs-apt&lt;/a&gt;
I get pull requests in my inbox on a weekly basis implementing some kind of
feature. This is really cool. It means people found bugs, fixed them or
implemented new ones (features that is, we&amp;nbsp;hope).&lt;/p&gt;
&lt;p&gt;But&amp;#8230; modules have tests and when you submit a &lt;span class="caps"&gt;PR&lt;/span&gt; without tests, the only
thing we will do is &lt;em&gt;ask for tests&lt;/em&gt;. We won&amp;#8217;t make an exception for you. If you
want your &lt;span class="caps"&gt;PR&lt;/span&gt; merged, it&amp;#8217;ll need to be up to&amp;nbsp;par.&lt;/p&gt;
&lt;p&gt;This&amp;nbsp;means:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It doesn&amp;#8217;t break current tests (yes this happens,&amp;nbsp;often);&lt;/li&gt;
&lt;li&gt;It introduces tests for the new/fixed behaviour (so we don&amp;#8217;t&amp;nbsp;regress).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We need to write and maintain modules that work for everyone and don&amp;#8217;t
accidentally break on people reaping havoc across their&amp;nbsp;machines.&lt;/p&gt;
&lt;p&gt;So what kind of tests do we expect? At the very least the acceptance tests
should be updated. Those spin up actual machines through Beaker and apply
(parts) of the module to machines and check its behaviour. If you can, or if
your change contains complex logic we&amp;#8217;d also appreciate updated rspec tests,
but those are&amp;nbsp;optional.&lt;/p&gt;
&lt;p&gt;In the end, the golden rules for contributing (to any opensource project really)&amp;nbsp;are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Submit &lt;span class="caps"&gt;PR&lt;/span&gt;&amp;#8217;s with tests. If you don&amp;#8217;t know how to write tests, put that in
   the &lt;span class="caps"&gt;PR&lt;/span&gt; too, so we know how to help&amp;nbsp;you;&lt;/li&gt;
&lt;li&gt;Work with us and we&amp;#8217;ll work with you. It&amp;#8217;s okay if you &lt;span class="caps"&gt;PR&lt;/span&gt; is not perfect or
   if you&amp;#8217;re unfamiliar with writing tests. As long as you&amp;#8217;re willing to put in
   the work we&amp;#8217;re willing to coach you. Perhaps you can have a look at this
   &lt;a href="http://puppet-a-day.com/blog/2014/04/22/modern-testing-of-modules/"&gt;post&lt;/a&gt; to
   get you&amp;nbsp;going;&lt;/li&gt;
&lt;li&gt;Don&amp;#8217;t ride off into the sunset. If you submit a &lt;span class="caps"&gt;PR&lt;/span&gt; we expect you to stick
   around for the follow-ups. If not then it&amp;#8217;ll simply not get merged. Not
   because we&amp;#8217;re mean, but because we too have a thousand other things to do&amp;nbsp;too.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you&amp;#8217;re contributing to a Puppetlabs module and you feel your &lt;span class="caps"&gt;PR&lt;/span&gt; isn&amp;#8217;t
getting the attention it deserves, stop by for the weekly Module Triage
hangout on Thursdays around 10 &lt;span class="caps"&gt;AM&lt;/span&gt; Portland Time. Links are posted in
the #puppet-dev on &lt;span class="caps"&gt;IRC&lt;/span&gt; and on the Puppet Developers mailing list&amp;nbsp;beforehand.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Daenney</dc:creator><pubDate>Wed, 23 Apr 2014 00:00:00 +0000</pubDate><guid>tag:puppet-a-day.com,2014-04-23:blog/2014/04/23/contributing-to-modules/</guid></item><item><title>Introducing Puppet-a-day</title><link>http://puppet-a-day.com/blog/2014/04/21/introducing-puppet-a-day/</link><description>&lt;p&gt;Welcome to &amp;#8220;Puppet a day&amp;#8221;. The idea of this blog is to become a collection of
community crowdsourced content about Puppet. You can publish your own content
instead of needing to host a blog yourself, repost it here or simply link to
an article on another blog or&amp;nbsp;site.&lt;/p&gt;
&lt;p&gt;The blog is run as an opensource project and is hosted on Github. You can
fork the project, create a &lt;span class="caps"&gt;PR&lt;/span&gt; against the &lt;code&gt;source&lt;/code&gt; branch and if it passes
review it will get merged and&amp;nbsp;published.&lt;/p&gt;
&lt;p&gt;We&amp;#8217;re by no means done working on this but it&amp;#8217;s &amp;#8220;good enough&amp;#8221; for release right
now. The theme is a heavily modified version of the Pure Pelican theme and
although better structured still messy in a bunch of places. There&amp;#8217;s no auto-
deploy yet either for when &lt;span class="caps"&gt;PR&lt;/span&gt;&amp;#8217;s get merged but we&amp;#8217;re working on adding&amp;nbsp;that.&lt;/p&gt;
&lt;p&gt;Looking forward to all your &lt;span class="caps"&gt;PR&lt;/span&gt;&amp;#8217;s!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Daenney</dc:creator><pubDate>Mon, 21 Apr 2014 00:00:00 +0000</pubDate><guid>tag:puppet-a-day.com,2014-04-21:blog/2014/04/21/introducing-puppet-a-day/</guid></item></channel></rss>